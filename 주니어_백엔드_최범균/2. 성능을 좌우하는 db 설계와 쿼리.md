# 2. 성능을 좌우하는 db 설계와 쿼리

## 1. 성능에 핵심인 db

- db 성능은 연동하는 모든 서버 성능에 영향을 줌.
    - db 자체의 문제보다 db를 잘 못 사용해서 발생한 문제가 많음.

## 2. 조회 트래픽을 고려한 인덱스 설계

- 일반적인 시스템에서는 조회 기능의 실행 비율이 높음.
- db 테이블을 설계할 때는 죄회기능과 트래픽 규모를 고려해야함.
    - 데이양이 적고 동시 접속자도 적다면 테이블을 풀 스캔하더라도 성능 문제가 발생하지 않음.
    - 그 반대라면, 다수의 풀 스캔이 발행하고, db 장비의 cpu 사용률이 높아지면서 기능을 하지 못함.
- `조회 패턴`을 기준으로 인덱스를 설계해야함.
    - 카테고리별, 사용자별 등등....

> [!note]
> 전문 검색 인덱스
> - like를 이용해서 조건을 지정하면 되나, 풀 스캔을 유발함.
> - 엘라스틱서치와 같은 검색 엔진을 이용하면 검색 기능 구현 가능
> - db가 제공하는 전문 검색 기능 사용을 고려해보자.
    >    - mysql FULLTEXT 인덱스 ..

### 2.1 단일 인덱스와 복합 인덱스

```sql
select *
from activityLog
where userId = 123
  and activityDate = '2024-07-31'
order by activityDatetime desc
```

- 사용자당 가질 수 있는 데이터가 얼마인지 대략 측정을 해야 함.
    - 적으면 단일 인덱스도 됨(userId).
    - 많으면 복합 인덱스로 하는 것이 좋음(userId, activityDate).

### 2.2 선택도를 고려한 인덱스 칼럼 선택

- 인덱스를 생성할 때는 `선택도`가 높은 칼럼을 선택해야 함.
    - 선택도는 인덱스에서 칼럼의 고유한 값의 비율
- 선택도가 낮아도 인덱스 칼럼으로 적합한 상황이 있음.
    - 쿼리를 실행할 때, 선택도가 낮지만 조회해야 하는 경우.
    - 예를 들어, status w(대기), p(처리 중), c(완료)의 값을 가지고, 값이 3개 이므로 선택도가 낮지만, 조회는 무조건 해야함.

### 2.3 커버링 인덱스 활용하기

- 특정 쿼리를 실행하는 데 필요한 칼럼을 모두 포함하는 인덱스.
- 쿼리 실행 효율을 높일 수 있음.
    - 랜덤 액세스가 발생하지 않음.

### 2.4 인덱스는 필요한 만큼만 만들기

- 사용자가 하루에 만들어 내는 데이터 개수가 조회 성능에 영향을 줄 만큼 많아야 함.
- 하루에 고작 수백 개 미만일 때에는 인덱스 추가 효과를 체감하기 어려움.
- 데이터 추가, 변경, 삭제 시에는 인덱스 관리에 따른 비용이 추가되고 메모리와 디스크 사용량도 함께 증가함.

## 3. 몇 가지 조회 성능 개선 방법

### 3.1 미리 집계하기

- count나 sum과 같은 집계 쿼리를 조회 시점에 실행하면서 성능 문제가 발생할 수 있음.
- <u>집계 데이터를 미리 계산해서 별도의 컬럼에 저장하면 됨.</u>

> [!check]
> 비정규화해도 괜찮아요?(servey테이블에 answer 집계 컬럼??)
> - 약간의 데이터 불일치를 감수하더라도 실시간 집계용 칼럼을 추가하는것이 성능에 좋다면 괜찮다.
> - 정확한 값은 다른 테이블에서 언제든지 구할 수 있다.

### 3.2 페이지 기준 목록 조회 대신 ID 기준 목록 조회 방식 사용하기

```sql
select id, subject, writer, regdt
from article
order by id desc limit 10
offset 99990
```

- 쿼리를 실행할 때, db는 어떤 id 값이 99,991 번째인지 알지 못함.
- 그래서 다 세고나서 나머지 10개를 조회함.

```sql
select *
from article
where deleted = false
order by id desc Limit 10;
```

- 위의 쿼리 결과로 조회한 마지막 data의 id가 9985라면, 다음 데이터는 앞서 읽어온 마지막 id를 사용해서 조회하면 됨.

```sql
select *
from article
where id < 9985
  and deleted = false
order by id desc limit 10;
```

- id는 인덱스이므로 바로 찾을 수 있음.
- <u>offset을 사용했을 때는 지정한 오프셋 만큼 데이터 세는 시간이 필요한데 이과정이 생략되어 실행되는 시간이 빠름.</u>

```sql
select *
from article
where id < 1001
  and deleted = false
order by id desc limit 11;
```

- 다음에 읽어올 데이터가 존재하는지 알려주는 속성을 추가해야 한다면 1개만 더읽어 판단하면 됨.
