# 1. 느려진 서비스, 어디서 부터 확인해야??

## 1.1 처리량과 응답시간

### 1.1.1 응답 시간

- 응답 시간 구성
    - api 요청
    - sql 실행, 응답 생성 ..
    - api 응답

- 응답 시간 측정 종류
    - TTFB(Time to First Byte) : 응답 데이터 중 첫 번째 바이트가 도착할 때까지 걸린 시간
    - TTLB(Time to Last Byte) : 응답 데이터의 마지막 바이트가 도착할 때까지 걸린 시간

> 전송할 데이터가 크거나 네트워크 속도가 느리면 위 둘의 차이가 커질 수 있기 때문에, 적절한 지표를 선택해 측정해야함.

- 처리 시간 중 `DB 연동`과 `외부 API 연동`이 큰 비중을 차지함.

### 1.1.2 처리량

- 단위 시간당 시스템이 처리하는 작업량
- 동시에 들어오는 요청 수가 최대 TPS를 초과하면 서버는 초과한 요청을 나중에 처리함. -> **응답 시간 지연**

#### 처리량 증가 방법

- 트래픽이 많은 시간대의 `TPS`와 `응답 시간`이 얼마인지 측정.
- 목표 TPS와 응답 시간을 설정하고 효과적인 성능 개선안을 도출.
    - 서버가 동시에 처리할 수 있는 요청 수를 늘려 대기시간 줄인다.
    - 처리 시간 자체를 줄여 대기 시간 줄인다.

## 1.2 서버 성능 개선 기초

### 1.2.1 병목 지점

- 처리 시간이 오래 걸리는 작업을 식별해서 병목 지점을 찾아야 함.
    - 주로 db, 외부 api 연동.

### 1.2.2 수직 확장과 수평 확장

#### 수직 확장

- 자원(cpu, 메모리 등등)을 증가 시키는 것을 의미한다.
- 장점
    - 사용자가 서비스를 이용하지 못하는 상황에서 이를 방치할 수 없다.
    - 빠른 조치를 위해 클라우드의 수직 확장을 할 수 있다.
    - 완전히 중단되는 것 보다 다소 느리더라도 서비스를 제공하고 문제의 원인을 찾고 해소할 방안을 찾는다.
- 단점
    - 즉각적인 효과를 얻을 수 있지만, 언젠가 결국 다른 성능 문제가 발생한다.
    - 비용이 많이 든다.

#### 수평 확장

- 트래픽이 증가하면 서버를 추가로 투입하는 방법 등을 말한다.
- 무턱대고 서버를 증가시키기 보다 실제 병목 지점을 파악해야 한다.
    - db에서 성능 문제가 발생하는데, db를 사용하는 서버를 늘린다면?? 최악이다.
- <u>성능 문제가 발생하지 않는 범위 내에서 수평 확장을 해야 효과가 있다.</u>

### 1.2.3 DB 커넥션 풀

- 네트워크에서 DB를 연결하고 종료하는 시간은 전체 응답 시간에 영향을 주기 때문에 미리 커넥션을 생성해 보관.
- db 작업이 필요할 때 가져오고, 끝나면 다시 반환.
- 이미 연결된 커넥션을 재사용하기 때문에 응답 시간이 줄어 든다.

#### 커넥션 풀 크기

- 커넥션 풀에 미리 생성해둘 커넥션 개수를 지정 하는 설정.
- 전체 응답 시간과 TPS를 고려하여 커넥션 풀 크기를 지정해야 한다.
    - 최대 TPS = 커넥션 수 / 평균 처리 시간
    - 커넥션 풀 크기가 5이고, 쿼리 실행 시간이 0.5라면 1초에 처리할 수 있는 요청수는 10개(1s/0.5s * 5개).
- 일반적인 커넥션 풀은 최소 크기와 최대 크기를 설정할 수 있음.
    - 최소 10개, 최대 20개일 경우, 10개를 유지하다 요청 수가 10개 넘어서 증가하면 20개까지 동적으로 커넥션을 늘린다.
    - 이후 동시 요청이 20개 이하로 줄면 커넥션 풀의 커넥션도 점차 줄어든다.

> - 트래픽이 순간적으로 급증하는 패턴을 보인다면 커넥션 풀의 최소 크기를 최대 크기에 맞추는 것이 좋다.
> - 트래픽이 급증할 경우 db 연결 시간도 성능 저하의 주요 원인이 될 수 있다.

- db 서버의 cpu 사용률이 80%에 육박하는 상황에서 커넥션 풀 크기를 늘리면 db에 가해지는 부하가 더 커져, 실행 시간이 증가할 수 있다.
    - 서버를 수평 확장하는 것도 커넥션 풀 크기를 늘리는 것과 동일하다.
- db 서버의 상태를 면밀히 확인한 후 확장을 해야한다.

#### 커넥션 대기 시간

- 커넥션 풀은 대기 시간을 설정할 수 있음.
- 커넥션이 없을 때 커넥션을 얻기 위해 기다릴 수 있는 최대 시간.
- 지정된 시간안에 커넥션을 구하지 못하면 db 연결 실패 에러가 남.
- 커넥션을 얻기 위해 대기하는 시간만큼 응답 시간도 길어진다..
- 응답 시간이 중요한 서비스는 커넥션 대기 시간을 가능한 짧게 설정해야 함.
    - 0.5 ~ 3초
    - 클라이언트가 요청을 취소하고 다시 요청한다면, 서버는 일정시간 동안 하던 작업을 중단하지 않기 때문에 이 시점의 대기 중이 요청 수가 증가한다.
- 대기 시간을 짧게 설정하면 서버 부하를 일정 수준으로 유지할 수 있고, 서버를 안정적으로 운영하는데 도움된다.

#### 최대 유휴 시간

- 사용되지 않는 커넥션을 풀에 유지할 수 있는 최대 시간을 의미한다.
- 커넥션이 사용되지 않는 시간이 길어지면 연결이 끊길 수 있다.
    - 일정 시간 이상 사용되지 않으면 DB와의 연결이 끊는 기능이 있다.
- DB에 설정된 비활성화 유지 시간보다 짧게 설정하면, DB가 연결을 끊기 전에 풀에서 커넥션을 제거할 수 있다.
    - 필요할 때, 클라이언트에서 재연결.
    - DB가 커넥션을 끊어버리면, 커넥션 풀은 그것을 모른채 사용하려다 예외가 발생할 수 있음.
    - 불필요한 커넥션 제거하여 자원 낭비 방지.

#### 유효성 검사

- 커넥션이 정상적으로 사용할 수 있는 상태인지 여부를 확인하는 절차.
- 연결이 유효하지 않은 커넥션을 식별하고 풀에서 제거할 수 있다.

#### 최대 유지 시간

- 이 시간이 지나면 커넥션이 유효하더라도 커넥션을 닫고 풀에서 제거한다.

### 1.2.4 서버 캐시

- 캐시를 사용하여 응답 시간을 줄일 수 있음.

### 1.2.5 적중률과 삭제 규칙

- 캐시가 얼마나 효율적으로 사용되는지는 적중률로 판단할 수 있음.
- 적중률이 높을 수록 db와의 연동이 줄어들고 응답 시간이 개선됨.
- 적중률을 높이는 가장 간단한 방법은 캐시에 최대한 많은 데이터를 저장하는 것.
- 메모리 용량은 한계가 있기 때문에 캐시에 저장할 수 있는 데이터 개수나 크기도 제한.
- 캐시가 가득차 있는 상태에서 새로운 데이터를 캐시에 저장하면 기존에 있던 데이터 중 하나를 제거해야 함.
- 유효 시간을 설정하는 방식도 함께 사용함.

### 1.2.6 로컬 캐시와 리모트 캐시

#### 로컬 캐시

- 서버 프로세스와 캐시가 동일한 메모리 공간을 사용하므로 캐시 데이터에 빠르게 접근 가능.
- 캐시에 저장할 수 있는 크기가 제한적.

#### 리모트 캐시

- 서버 프로세스는 캐시 프로세스와 데이터를 주고받기 위해 네트워크 통신을 해야 함.
- 로컬 캐시보다 느림.
- 별도의 서버 장비가 필요하기 때문에 시스템 구조가 복잡해 짐.
- 레디스 사용 시 저장된 캐시 데이터는 종료되도 그대로 유지 됨(RDB snapshot, AOF(따로 활성화 해야함.)).

> - 데이터 규모가 작고, 변경에 민감하지 않고, 변경 빈도가 낮다면 `로컬 캐시`
> - 데이터 규모가 크고, 변경에 민감하고, 배포 빈도가 높다면, `리모트 캐시` 

### 1.2.7 메모리 사용
- 한 번에 대량으로 객체를 생성하는 것을 주의해야 함.
  - 한 번에 너무 많은 객체를 생성하면, 대량 요청 시 메모리 부족이 발생할 수 있음.
  - 파일 데이터를 한꺼번에 메모리에 로딩한 후 응답하는 방식은 피해야 함.
- 대량으로 객체가 생성되는 것을 방지하려면 조회 범위를 제한해야 함.

### 1.2.8 대기 처리
- db는 쉽게 증설할 수 없기 때문에 예상되는 트래픽에 맞춰 미리 증설해야함.
- 최대 트래픽에 맞춰 db 성능을 높여 놓으면 다시 db 성능을 줄이기가 쉽지 않음.
- 수용할 수 있는 수준의 트래픽만 받아들이고 나머지는 `대기 처리`할 수 있음.
  - 서버를 증설하지 않고도 서비스를 안정적으로 제공 가능.
  - 새로 고침으로 인한 트래픽 폭증도 방지 가능. -> 새로 고침하면 순번이 뒤로 밀림.
- 서비스 자체가 아예 안되는 것보다 대기하는 것이 나을 수도.





